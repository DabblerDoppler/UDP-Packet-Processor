const logic [5:0] HEADER_SIZE = 42;

module header_parser (
    input  logic         clk,
    input  logic         rst_n,

    // AXI-Stream style input interface
    input  logic  [255:0]  in_data,
    input  logic  [31:0]   in_keep,
    input  logic           in_valid,
    input  logic           in_last,

    // Output: raw UDP payload stream
    output logic  [255:0]  out_data,
    output  logic  [31:0]  out_keep,
    output logic           out_valid,
    output logic           out_last,

    output logic timestamp_valid,
    //The time (in clock cycles) since we received the last packet
    output logic [31:0] timestamp,

    input logic  out_ready,
    output logic in_ready
);

    typedef enum logic[1:0] {
        IDLE, 
        PARSE_HEADER,
        STREAM_PAYLOAD 
    } parse_state;

    parse_state state;
    logic [511:0] packet_buffer;
    logic [5:0]   valid_bytes;
    logic prev_buffer_valid;
    logic buffer_valid;

    logic[31:0] cycle_count, packet_start_timestamp;

    cycle_counter timestamper(.clk, .rst_n, .cycle_count);


    always @(posedge_ff or negedge rst_n) begin
        if(~rst_n) begin
            state <= IDLE;
            valid_bytes <= 1'b0;
            packet_buffer <= 1'b0;
            prev_buffer_valid <= 1'b0;
            buffer_valid <= 1'b0;
            packet_start_timestamp <= 32'b0;
            timestamp_valid <= 1'b0;
        end else begin
            case (state)
                IDLE: begin
                    timestamp_valid <= 0;
                    if(in_valid && in_ready) begin
                        packet_start_timestamp <= cycle_count;
                        packet_buffer[511:256] <= in_data;
                        valid_bytes <= popcount32(in_keep);
                        prev_buffer_valid <= in_valid;
                        state <= PARSE_HEADER;
                    end 
                end
                PARSE_HEADER: begin
                    //these are blocking statements intentionally - it allows us to skip a 
                    //clock cycle of latency and start parsing immediately.
                    packet_buffer[255:0] = in_data;
                    buffer_valid = prev_buffer_valid && in_valid && (valid_bytes + popcount32(in_keep) >= HEADER_SIZE);

                    valid_bytes <= valid_bytes + popcount32(in_keep);
                    //if we have a full valid header, start parsing the payload. 
                    if(header_valid) begin
                        packet_buffer <= 1'b0;
                        valid_bytes <= 1'b0;
                        prev_buffer_valid <= 1'b0;
                        buffer_valid <= 1'b0;
                        state     <= STREAM_PAYLOAD;
                    //Otherwise, our input data is too corrupted. We've recieved 2 words
                    //and still don't have a complete header, so we flush the buffer and 
                    //return to listening. 
                    //This is pretty aggressive, but for our use case, we don't want to get
                    //stuck on a bad input source while other packets are trying to be sent,
                    //so this is a deliberate design choice for HFT.
                    //It also lets us get away with simple buffer logic rather than a proper FIFO
                    //which helps to minimize latency.
                    end else begin
                        packet_buffer <= 1'b0;
                        valid_bytes <= 1'b0;
                        prev_buffer_valid <= 1'b0;
                        buffer_valid <= 1'b0;
                        state <= IDLE;
                    end
                end
                STREAM_PAYLOAD: begin
                    if(in_last) begin
                        state <= IDLE;
                        timestamp_valid <= 1'b1;
                        timestamp <= cycle_count - packet_start_timestamp;
                    end
                end
            endcase
        end
    end

    always_comb begin
        case (state) 
            IDLE: begin
                stream_data  = 256'b0;
                stream_keep  = 32'b0;
                stream_valid = 1'b0;
                stream_last  = 1'b0;
            end
            PARSE_HEADER: begin
                if(header_valid) begin
                    stream_data  = {80'b0, packet_buffer[175:0]};
                    stream_keep  = 32'h00_3F_FF_FF & in_keep;
                    stream_valid = in_valid;
                    stream_last  = 1'b0;
                end else begin
                    stream_data  = 256'b0;
                    stream_keep  = 32'b0;
                    stream_valid = 1'b0;
                    stream_last  = 1'b0;
                end
            end
            STREAM_PAYLOAD: begin
                stream_data   = in_data;
                stream_keep   = in_keep;
                stream_valid  = in_valid;
                stream_last   = in_last;
            end
            default: begin
                stream_data = 256'b0;
                stream_keep = 32'b0;
                stream_valid = 1'b0;
                stream_last = 1'b0;
            end
        endcase
    end

    logic fifo_wr_en, fifo_rd_en, fifo_full, fifo_empty, bypass_fifo, fifo_valid;
    logic [255:0] stream_data, fifo_data;
    logic [31:0]  stream_keep, fifo_keep;
    logic         stream_last, fifo_last, stream_valid, bypass_valid;

    fifo payload_fifo (
        .clk       (clk),
        .rst_n     (rst_n),
    
        // Write interface
        .wr_en     (fifo_wr_en),
        .wr_data   (stream_data),
        .wr_keep   (stream_keep),
        .wr_last   (stream_last),
        .full      (fifo_full),
    
        // Read interface
        .rd_en     (fifo_rd_en),
        .rd_data   (fifo_data),
        .rd_keep   (fifo_keep),
        .rd_last   (fifo_last),
        .empty     (fifo_empty)
    );

    assign bypass_fifo = in_valid && out_ready && fifo_empty;
    assign fifo_valid   = ~fifo_empty;

    assign out_data  = bypass_fifo ? stream_data : fifo_data;
    assign out_keep  = bypass_fifo ? stream_keep : fifo_keep;
    assign out_last  = bypass_fifo ? stream_last : fifo_last;
    
    assign out_valid = bypass_fifo ? stream_valid : fifo_valid;

    assign in_ready = bypass_fifo ? out_ready : !fifo_full;

    assign fifo_wr_en = ~bypass_fifo && stream_valid;
    assign fifo_rd_en = out_ready && fifo_valid && ~bypass_fifo;


    logic filters_valid, header_valid;
    logic cfg_we;
    logic [3:0] cfg_waddr, cfg_raddr;
    logic [31:0] cfg_wdata, cfg_rdata;


    filter_core my_filter_core(.clk, .rst_n, .data(packet_buffer), 
    .cfg_we, .cfg_waddr, .cfg_wdata, .cfg_raddr, .cfg_rdata, .filters_valid);

    //If in_last is high in the header stage, our packet is malformed so we should drop it.
    assign header_valid = filters_valid && buffer_valid && ~in_last;



    input logic rst_n,

    input axi_stream axi,

    output logic eth_valid,
    //EtherType is 2 bytes
    output logic [15:0] ethertype;
    output logic [47:0] source_mac;
    output logic [47:0] dest_mac;


function automatic [5:0] popcount32(input logic [31:0] x);
    popcount32 = 
        x[0]  + x[1]  + x[2]  + x[3]  +
        x[4]  + x[5]  + x[6]  + x[7]  +
        x[8]  + x[9]  + x[10] + x[11] +
        x[12] + x[13] + x[14] + x[15] +
        x[16] + x[17] + x[18] + x[19] +
        x[20] + x[21] + x[22] + x[23] +
        x[24] + x[25] + x[26] + x[27] +
        x[28] + x[29] + x[30] + x[31];
endfunction

always_comb begin
    valid_bytes = popcount32(in_keep);
end


endmodule

module header_parser_testbench;

    // Parameters
    parameter WIDTH = 256;

    // DUT Inputs
    logic clk;
    logic rst_n;
    logic [WIDTH-1:0] in_data;
    logic [31:0]      in_keep;
    logic             in_valid;
    logic             in_last;
    logic             out_ready;

    // DUT Outputs
    logic [WIDTH-1:0] out_data;
    logic [31:0]      out_keep;
    logic             out_valid;
    logic             out_last;
    logic [31:0]      timestamp;
    logic             in_ready;

    // Instantiate DUT
    header_parser dut (
        .clk,
        .rst_n,
        .in_data,
        .in_keep,
        .in_valid,
        .in_last,
        .out_data,
        .out_keep,
        .out_valid,
        .out_last,
        .timestamp,
        .in_ready,
        .out_ready
    );

    // Clock generation
    always #5 clk = ~clk;

    task reset();
        rst_n = 0;
        in_valid = 0;
        out_ready = 1;
        clk = 0;
        #20;
        rst_n = 1;
        #10;
    endtask

    task send_packet(input [WIDTH-1:0] d0, input [31:0] k0,
                     input [WIDTH-1:0] d1, input [31:0] k1,
                     input bit last_on_second);
        @(posedge clk);
        in_valid = 1;
        in_data  = d0;
        in_keep  = k0;
        in_last  = 0;
        @(posedge clk);
        in_data  = d1;
        in_keep  = k1;
        in_last  = last_on_second;
        @(posedge clk);
        in_valid = 0;
        in_last  = 0;
    endtask

    initial begin
        reset();

        // Test 1: send a 2-cycle packet with a valid, matching header.
        send_packet(256'hDEADBEEF_CAFEFEED_01234567_89ABCDEF_00000000_00000000_00000000_00000000,
                    32'hFFFF_FFFF,
                    256'h11223344_55667788_99AABBCC_DDEEFF00_00000000_00000000_00000000_00000000,
                    32'h0000_FFFF,
                    1'b1);
        // Test 2: send a packet with a nonmatching UDP port.
        send_packet(
            {
                16'hCAFE, 32'hDEADBEEF,
                48'h010203040506,
                16'h0800,
                8'h45, 8'h00,
                16'h0020, 16'h0000,
                16'h0000,
                8'h40, 8'h11,
                16'h0000,
                32'h0A000101,
                32'h0A000102
            }, 32'hFFFF_FFFF,
        
            {
                16'd12345,            // Source port
                16'd12346,            // Non-matching dest port
                16'h000C, 16'h0000,
                192'h0
            }, 32'h0000_FFFF,
        
            128'hDEAD_CAFE_BEEF_CAFE_DEAD_CAFE_BEEF_CAFE; //Payload
        );
        // Test 3: Invalid Ethertype. 
        //With current logic, this behaves the same as the previous test, but I plan to 
        //
            send_packet(
                {
                    16'hCAFE, 32'hDEADBEEF,
                    48'h010203040506,
                    16'h86DD,             // Ethertype: IPv6 (should fail)
                    8'h45, 8'h00,
                    16'h0020, 16'h0000,
                    16'h0000,
                    8'h40, 8'h11,
                    16'h0000,
                    32'h0A000101,
                    32'h0A000102
                }, 32'hFFFF_FFFF,
            
                {
                    16'd12345, 16'd25565,
                    16'h000C, 16'h0000,
                    192'h0
                }, 32'h0000_FFFF,
            
                128'hDEAD_CAFE_BEEF_CAFE_DEAD_CAFE_BEEF_CAFE;  //Payload
            );     
        //Test 4: Garbage packet
        send_packet(
            256'hFFFF_DEAD_BEEF_CAFE_00000000_00000000_00000000_00000000,  // Random garbage
            32'h0000_0FFF,  // Only 12 bytes valid
            256'h0,         // Second beat is missing
            32'h0000_0000,
            1'b1
        );   

        repeat (10) @(posedge clk);  // Wait for output to flush

        $display("Simulation finished.");
        $finish;
    end

endmodule

